# javascript 일반_1-1 함수2

지난시간에는 함수의 기능에 대해 알아보았습니다.
이번시간에는 함수의 정의와 종류 및 용어들에 대해 알아보도록 하겠습니다.
내용상 이전 시간에 설명한 부분과 겹치는 부분들이 있습니다. 
간단하게 상기시키면서 지나가시면 될듯 합니다. ^^

---

[TOC]

---

## 함수(function) 

**함수란?** 기본적으로 커다란 스크립트에 들어가는 작은 스크립트 라고 설명드렸습니다.
좀더 쉽게 말하자면 함수는 **JavaScript에서 기본적인 빌딩 블록 중의 하나**입니다. 함수는 작업을 수행하거나 값을 계산하는 문장 집합 같은 자바스크립트 절차입니다. 
**함수를 사용하려면 함수를 호출하고자 하는 범위 내에서 함수를 정의** 해야만 합니다.

자바스크립트내에서 함수는 **일급 객체** 라고 불리웁니다.
**일급 객체란?**

- 변수(variable)나 데이터 구조 안에 담을 수 있다.
- 인자(parameter)로 전달 할 수 있다.
- 반환값(return value)으로 사용 할 수 있다.

자바스크립트는 일급객체 뿐아니라 **일급 함수**라는 것도 가집니다.
**일급함수란?**

- 런타임(runtime)에 생성될 수 있다.
- 익명(anonymous)으로 생성이 가능하다



> **런타임이란?**
>  [컴퓨터 과학](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)에서 [컴퓨터 프로그램](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8)이 실행되고 있는 동안의 동작을 말합니다.
>  "**런타임**"이라는 용어는 [컴퓨터 언어](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0_%EC%96%B8%EC%96%B4) 안에 쓰인 프로그램을 관리하기 위해 특정한 [컴파일러](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC)나 [가상 머신](https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81_%EB%A8%B8%EC%8B%A0)이 사용하는 기본 코드의 라이브러리나 프로그램을 가리키는 [런타임 라이브러리](https://ko.wikipedia.org/wiki/%EB%9F%B0%ED%83%80%EC%9E%84_%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)라고도 말합니다.

---

## 함수의 정의

그에 따른 함수를 정의 하는 방법에는 아래와 같은 방법이 있습니다.

- **함수 표현식** (function expression)
- **함수 선언식** (function declaration)
- **생성자(객체) 함수** (constructor function)

---

### 함수 표현식

```javascript
var add = function(x,y){
  return x + y;
};
```

변수를 할당하고 해당하는 **변수에 함수를 대입**하여 처리하는 방법입니다.
변수의 끝을 알리기 위해 **마지막에 세미콜론을 붙이는 것**도 특징입니다.
이전 시간에도 진행했던 방법으로 가장 많이 사용하고 있으며 권장하는 방법입니다.

함수 표현식은 **함수 리터럴**로 특정 변수에 할당되거나 즉시 실행 가능한 코드 블럭으로 존재하는 함수를 의미합니다.
함수 표현 자체를 실행코드로 진행하며 변수이름뒤에`( )`를 붙이면 함수를 호출하게 되는 방법입니다.

함수표현식은 함수자체에는 이름이 존재하지 않는 것이 일반적입니다. 
(함수자체에 이름을 붙이는것이 불가능한 것은 아니지만 자주 사용하지 않습니다.)
그렇기에 **익명함수 **로 불리기도 합니다.
(함수에 이름이 붙으면 익명함수로 불릴 수 없습니다.)
**정확하게 말하자면 익명함수는 함수표현식을 가진다입니다.**

함수표현식의 경우 변수에 할당하는 기법이기 때문에 **호이스트** 현상이 일어납니다.
하지만 변수의 호이스트와 마찬가지로 변수의 이름만 최상단으로 이동하고 
대입되는 **함수 자체는 호이스트 처리되지 않습니다.**
이점 유의하세요.

이전 시간부터 자주 언급하던 내용이기 때문에 여기까지 진행하겠습니다.

---

### 함수 선언식

```javascript
function addFn(x,y){
  return x + y;
}
```

위 코드는 함수 선언식 이라고 합니다.
함수를 미리 정의(선언)하고 다음과 같은 키워드의 내용으로 기본 구성하고 있습니다.
함수 선언식은 변수와 마찬가지로 **호이스트** 현상이 일어납니다.

- 함수의 이름
- 괄호 안에서 콤마로 분리된 함수의 인수 목록 
- 중괄호 { } 안에서 함수를 정의하는 자바스크립트 표현

함수 표현식과 비교하자면 선언식은 변수에 할당된 함수가 아닌 함수자체에 이름을 부여한 형식 이라는 것입니다.

그렇기 때문에 함수 선언식은 호이스트 처리시 내용이 모두 최상단으로 이동하게 됩니다.
변수와는 또다른 현상입니다. 
더 얘기하자면, 변수보다 상위로 이동하게 되는 셈 입니다.

```javascript
console.log(test1);						
console.log(test2);
console.log(myHoist());
console.log(test2());

var hoistTest = 'my text';
var test1 = 'test1';
var test2 = function(){
  return 'hoist test';
};
function myHoist(){
  return 'hoistTest';
}
```

위 코드는 **호이스트**(Hoist)를 확인하기 위해 작성된 코드입니다.
첫번째와 두번째의 결과물은 `undefined`입니다.
세번째는 **hoistTest** 라는 결과물을 얻을 수 있습니다.
마지막 네번째는 `TypeError`를 표기하고 있습니다. 

위 코드의 최종 결과물을 확인해보면 아래와 같습니다.

```javascript
function myHoist(){
  return 'hoistTest';
}									// 함수 표현식의 경우에 ';'를 표기

var hoistTest,test1,test2;

console.log(test1);						
console.log(test2);
console.log(myHoist());
console.log(test2());

hoistTest = 'my text';
test1 = 'test1';
test2 = function(){
  return 'hoist test';
};									// 함수 표현식의 경우에 ';'를 표기
```

위 코드를 보면 왜 그런 결과물이 나온지를 알 수 있습니다.
함수표현식과, 함수 선언식의 큰 차이를 알 수 있는 내용입니다.
차후 많은 부분에서 사용할 수 있습니다 기억하시고 사용하시길 권합니다.

---

### 생성자 함수

```javascript
var add = new Function('x','y','return x+y;');
```

생성자 함수의 경우는 `function(){}`의 내용으로 사용하지만, 표현방법은 매우 다릅니다.
`new Function();`형태의 표현을 가집니다.
함수표현 앞에 `new`라는 표현을 사용하며, 이를 **생성자(Instance)**라고 합니다.
실제로 많이 사용하는 경우는 없으나 내용은 간단하게 알아두세요.

**생성자에 대한 이해는 차후 좀더 다루도록 하겠습니다.**

---

## 함수의 종류

함수에대한 정의에대해 다시 정리해 보았으니 이제 함수의 다양한 종류에대해 알아보도록 하겠습니다.

- [익명함수](#noneName)
- [중첩함수](#innerFn)
- [콜백함수(call back)](#callBack)
- [**즉시 실행 함수** (**IIFE**: Immediately Invoked Function Expressions)](#iife)
- 내장함수
- 재귀함수
- 클로저
- 화살표 함수 (ECMA6이후 생성된 기능)

이외에도 꽤 많은 함수들이 존재합니다. 
하지만 위 기능들만 잘 알아도 어디가서 함수 다루지 못한다는 소리는 들을 수 없습니다.

---

### 익명함수<div id="noneName"></div>

함수 리터럴을 이용해 정의된 함수를 익명함수 라고 합니다.
함수의 이름이 없기 때문에 익명함수라고 불리우고 있으며, 
주로 변수에 할당되거나 함수 인자의 값 또는 반환값으로 사용되어 집니다.

함수표현식에 사용하는 함수가 대부분이 익명함수입니다.

```javascript
var NoNameFn = function(){
  var fnName = '함수의 이름이 정의되지 않았으므로, 호출된 함수는 익명함수 입니다.';
  return fnName;
};

console.log( NoNameFn() );
```

---

### 중첩함수<div id="innerFn"></div>

```javascript
function example(){
  var  a = 1;
  function oneMore(){
    return a + 1;
  }
  return oneMOre();
}
```

 위 코드는 함수 **내부에 또다른 함수를 사용하여 중첩처리하는 형태**입니다.
주로 특정 함수에서만 사용할 기능을 외부에 노출시키지 않고 내부에 정의해서 사용할 경우에 많이 사용하는 방법입니다.

변수는 지역변수 및 전역변수 등이 존재합니다.
이는 각 변수의 영역(**scope**)이 존재하고, 해당영역은 함수의 구분으로 이루어지게되는데 
이때 내부에 존재하는 함수를 별도로 참조하거나 할수 있습니다.

이를 활용하여 **객체지향의 캡슐화, 은닉화** 등으로 처리할 수 있는 방법들이 될 수 있습니다.

즉, 전역 변수 이름공간을 과도하게 사용하지 않고 연관된 함수를 묶어 처리할수 있는 것 입니다.
이는 전역 범위의 함수의 수를 낮게 유지할 수 있는 방법 중의 하나입니다.

---

### 콜백함수<div id="callBack"></div>

[콜백함수](https://opentutorials.org/module/532/6508)
자바스크립트에서 가장 많이 사용하는 기법중에 하나가 바로 콜백함수 입니다.
콜백함수는 [jQuery](http://jquery.com)나 각종 자바스크립트 라이브러리등에서 많이 사용되고 있습니다.

콜백함수의 가장 중요한 핵심 중에 하나는 **함수를 인자로 넘겨사용한다** 입니다.

```javascript
function doFn(callback){
    // doFn 에서 실행 될 내용들
    var a = 1;
    var b = 1;
    var c = a + b;
     
    alert('doFn 에서 실행 될 내용이 실행된다.');
 
    // doFn에서 실행 될 내용들 실행 후 인자값으로 받은 callback을 실행
    // 넘겨받은 callback이 함수이기 때문에 실행 가능.
    // 이때 c 값을 인자값으로 넘겨준다.
    if(typeof callback === 'function') {
        callback(c);
    }
}
```

위 내용은 함수 `doFn`을 생성 후 
함수내부에 변수 `a, b, c`를 생성하고, 
어떠한 조건을 준비하여 확인하도록 처리한 값 입니다.

실제로 `doFn();`을 입력하여 함수를 호출하여도 메세지 창 하나만 뜰 뿐 입니다.
하지만 `doFn();`에는 인자값을  추가로 담을 수 있도록 짜여진 상태 입니다.

```javascript
// 먼저 doFn 실행 시키고 callback 함수에 의해 function 안의 내용이 실행
doFn(function(msg){
    // doFn 함수의 호출에 의해서 실행된다.
    // 인자값으로 받은 c값을 msg 로 받는다.
    alert('callback 함수의 실행 될 내용');
    alert('c 의 값은? ' + msg);
});
```

다소 복잡해 보이지만 나타나는 메세지창과 
내용의 흐름을 익혀서 이해해 보도록 하겠습니다.

위 내용은 함수 `doFn();`를 호출하고, 해당함수의 인자값으로
 별도의 함수`function(msg){}`를 생성하여 담은 형태 입니다.

- 콜백함수는 **A**에 있는 함수를 다른곳에 전달하여 다른곳에서 **A** 의 함수를 호출하는 법 입니다.

다소 복잡하고 어려운 내용일 수 있습니다.
하지만 콜백함수의 내용을 잘 이해한다면 jQuery 뿐아니라 
다양한 라이브러리내용을 이해할 수 있고, 
중요한 자료를 캡슐, 은닉화 처리할 수 있다는 장점이 생겨지게 됩니다.
또한 차후 익히게 될 [node.js](nodejs.org) 내용에서 자주 사용하고 있기 때문에 
기초 지식으로써 꾸준이 이해해야 합니다.

콜백함수를 사용하면 클로저 라는 단어도 자주 접하게 됩니다.
클로저의 관련내용은 차후에 다시 진행하겠습니다.

---

### 즉시실행함수(IIFE)<div id="iife"></div>

```javascript
(function(){
  console.log('jquery Go!');
})();
```

위 코드의 형태는 즉시실행함수의 코드형태입니다.
함수 표현(Function expression)은 함수를 정의하고, 변수에 함수를 저장하고 실행하는 과정을 거칩니다. 
하지만 즉시 실행 함수는 함수를 정의하고 바로 실행하여 이러한 과정을 거치지 않는 특징이 있습니다. 
함수를 정의하자마자 바로 호출하는 것을 즉시 실행 함수라고 이해하면 편합니다.

즉시실행함수를 사용하는 방법은 크게 3가지 방법이 있습니다.

```javascript
(function(/*인자*/){ /*필요내용 작성 */ })(/*인자값*/);		// 방법 1
(function(/*인자*/){ /*필요내용 작성 */ }(/*인자값*/));		// 방법 2
!function(/*인자*/){ /*필요내용 작성 */ }(/*인자값*/);			// 방법 3
```

위 3가지 방법 외에도 몇가지 방법들이 존재하지만 결과는 모두 동일합니다.
즉시실행함수를 사용하는 이유는 함수를 작성하고 별도로 호출하여 사용하지 않아도 될때 사용하는 것이 가장 큰 특징으로 볼 수 있습니다.

```javascript
var mySquare = (function (x) {
    return x*x;
})(2);								// 변수 'mySquare'에 대입된 함수의 인자 'x'의 값을 2로 할당

console.log(mySquare);
```

즉시 실행함수도 함수의 종류중에 하나이기 때문에 변수에 저장하여 사용하는 것도 가능합니다. 
그렇다면 즉시실행함수는 왜 어떻게 사용하는 것일까요?

---

#### 초기화

즉시 실행 함수는 한 번의 실행만 필요로 하는 초기화 코드 부분에 많이 사용됩니다.
**변수를 전역(global scope)으로 선언하는 것을 피하기 위해서 입니다. **
전역에 변수를 추가하지 않아도 되기 때문에 코드 충돌 없이 구현 할 수 있어, 
플러그인이나 라이브러리 등을 만들 때 많이 사용됩니다.

```javascript
var initText;

(function (number) {
    var textList = ["is Odd Text", "is Even Text"];
    if (number % 2 == 0) {
        initText = textList[1];
    } else {
        initText = textList[0];
    }
})(5);
 
console.log(initText);
console.log(textList);
```

전역에 textList가 저장되지 않고, initText만 초기화 된 것을 확인 할 수 있습니다. 
또한 textList는 지역 변수로, 전역 변수와 충돌없이 초기화 할 수 있게 됩니다.
변수의 범위(**scope**)의 내용은 다음시간에 설명드리도록 하겠습니다.

---

#### 라이브러리 전역 변수의 충돌

```javascript
(function ($) {
    // $ 는 jQuery object
})(jQuery);
```

위 코드는 실제로 jQuery코드의 작성에서 사용하는 형태입니다.

Query나 Prototype 라이브러리는 동일한 $라는 전역 변수를 사용합니다. 
만약, 이 두개의 라이브러리를 같이 사용한다면 $ 변수 충돌이 생기게 됩니다.

**즉시 실행 함수를 사용하여 $ 전역 변수의 충돌을 피할 수 있습니다.**

---

이번시간에는 여기까지 보도록 하겠습니다 다음시간에는 남은 함수에 대해 설명하도록 하겠습니다. 

